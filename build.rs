use handlebars::Handlebars;
use serde_json::json;
use rustc_hash::FxHashMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(serde::Deserialize, Debug)]
struct ScriptMetadata {
    name: String,
    script_type: String,
    has_implicit_a: bool,
}

#[derive(serde::Deserialize, Debug)]
struct ScriptMappings {
    vowels: Option<FxHashMap<String, String>>,
    consonants: Option<FxHashMap<String, String>>,
    vowel_signs: Option<FxHashMap<String, String>>,
    marks: Option<FxHashMap<String, String>>,
    digits: Option<FxHashMap<String, String>>,
    sanskrit_extensions: Option<FxHashMap<String, String>>,
    special: Option<FxHashMap<String, String>>,
}

#[derive(serde::Deserialize, Debug)]
struct CodegenConfig {
    processor_type: String,
}

#[derive(serde::Deserialize, Debug)]
struct ScriptSchema {
    metadata: ScriptMetadata,
    target: Option<String>, // "iso15919" for Roman, "devanagari" for Indic (default)
    mappings: ScriptMappings,
    codegen: Option<CodegenConfig>,
}

fn main() {
    println!("cargo:rerun-if-changed=schemas/");

    if let Err(e) = generate_schema_based_converters() {
        println!("cargo:warning=Failed to generate schema-based converters: {e}");
    }
}

fn generate_schema_based_converters() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let schemas_dir = Path::new("schemas");

    // Initialize Handlebars template engine
    let mut handlebars = Handlebars::new();
    handlebars.register_template_file("roman_converter", "templates/roman_converter.hbs")?;
    handlebars.register_template_file(
        "roman_to_devanagari_direct",
        "templates/roman_to_devanagari_direct.hbs",
    )?;
    handlebars.register_template_file(
        "indic_standard_converter",
        "templates/indic_standard_converter.hbs",
    )?;
    handlebars.register_template_file(
        "indic_extended_converter",
        "templates/indic_extended_converter.hbs",
    )?;

    // Register helper functions for templates
    handlebars.register_helper("uppercase", Box::new(uppercase_helper));
    handlebars.register_helper("lowercase", Box::new(lowercase_helper));
    handlebars.register_helper("capitalize", Box::new(capitalize_helper));
    handlebars.register_helper("escape", Box::new(escape_helper));

    let mut generated_code = String::new();
    let mut converter_registrations = Vec::new();

    // Add header
    generated_code.push_str(
        r#"
// Auto-generated converters from TOML/YAML schemas
// DO NOT EDIT - Generated by build.rs at compile time

use once_cell::sync::Lazy;
use crate::modules::script_converter::processors::RomanScriptProcessor;
use crate::modules::hub::{HubFormat, HubTrait};

"#,
    );

    // Process YAML schemas
    if schemas_dir.exists() {
        for entry in fs::read_dir(schemas_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("yaml") {
                println!("cargo:rerun-if-changed={}", path.display());

                let content = fs::read_to_string(&path)?;
                let schema: ScriptSchema = serde_yaml::from_str(&content).map_err(|e| {
                    format!("Failed to parse YAML schema {}: {}", path.display(), e)
                })?;

                // Skip Devanagari as it's the hub script and handled directly
                if schema.metadata.name.to_lowercase() == "devanagari" {
                    continue;
                }

                let converter_code =
                    generate_converter_from_schema(&handlebars, &schema).map_err(|e| {
                        format!(
                            "Failed to generate converter for {}: {}",
                            schema.metadata.name, e
                        )
                    })?;
                generated_code.push_str(&converter_code);

                converter_registrations.push(format!(
                    "{}Converter",
                    capitalize_first(&schema.metadata.name)
                ));

                // For Roman scripts targeting ISO-15919, also generate direct Roman → Devanagari converter
                if schema.metadata.script_type == "roman" && schema.target.as_deref() == Some("iso15919") {
                    let devanagari_converter_code = generate_roman_to_devanagari_converter(
                        &handlebars, 
                        &schema
                    ).map_err(|e| {
                        format!(
                            "Failed to generate Roman→Devanagari converter for {}: {}",
                            schema.metadata.name, e
                        )
                    })?;
                    generated_code.push_str(&devanagari_converter_code);

                    converter_registrations.push(format!(
                        "{}DevanagariConverter",
                        capitalize_first(&schema.metadata.name)
                    ));
                }
            }
        }
    }

    // Add registration function
    generated_code.push_str(&format!(r#"
/// Register all schema-generated converters
pub fn register_schema_generated_converters(registry: &mut crate::modules::script_converter::ScriptConverterRegistry) {{
{}
}}
"#, 
        converter_registrations.iter()
            .map(|name| format!("    registry.register_converter(Box::new({name}::new()));"))
            .collect::<Vec<_>>()
            .join("\n")
    ));

    // Write generated code
    fs::write(out_dir.join("schema_generated.rs"), generated_code)?;

    Ok(())
}

fn generate_converter_from_schema(
    handlebars: &Handlebars,
    schema: &ScriptSchema,
) -> Result<String, Box<dyn std::error::Error>> {
    let script_name = &schema.metadata.name;
    let struct_name = format!("{}Converter", capitalize_first(script_name));

    // Determine processor type based on target or script_type
    let processor_type = schema
        .codegen
        .as_ref()
        .map(|c| c.processor_type.as_str())
        .unwrap_or_else(|| {
            // Use target field to determine processor type
            match schema.target.as_deref() {
                Some("iso15919") => "roman",
                Some("devanagari") => "indic_standard",
                None => {
                    // Fallback to script_type for backward compatibility
                    if schema.metadata.script_type == "roman" {
                        "roman"
                    } else {
                        "indic_standard"
                    }
                }
                _ => "indic_standard",
            }
        });

    // Combine all mappings
    let mut all_mappings = FxHashMap::default();
    if let Some(ref vowels) = schema.mappings.vowels {
        all_mappings.extend(vowels.clone());
    }
    if let Some(ref consonants) = schema.mappings.consonants {
        all_mappings.extend(consonants.clone());
    }
    if let Some(ref vowel_signs) = schema.mappings.vowel_signs {
        all_mappings.extend(vowel_signs.clone());
    }
    if let Some(ref marks) = schema.mappings.marks {
        all_mappings.extend(marks.clone());
    }
    if let Some(ref digits) = schema.mappings.digits {
        all_mappings.extend(digits.clone());
    }
    if let Some(ref sanskrit_extensions) = schema.mappings.sanskrit_extensions {
        all_mappings.extend(sanskrit_extensions.clone());
    }
    if let Some(ref special) = schema.mappings.special {
        all_mappings.extend(special.clone());
    }

    match processor_type {
        "roman" => generate_roman_converter_with_template(
            handlebars,
            &struct_name,
            script_name,
            &all_mappings,
            &schema.metadata,
        ),
        "indic_standard" => generate_indic_converter_with_template(
            handlebars,
            &struct_name,
            script_name,
            &all_mappings,
            &schema.metadata,
        ),
        "indic_extended" => generate_extended_indic_converter_with_template(
            handlebars,
            &struct_name,
            script_name,
            &all_mappings,
            &schema.metadata,
        ),
        _ => Err(format!("Unknown processor type: {processor_type}").into()),
    }
}

fn capitalize_first(s: &str) -> String {
    // Convert kebab-case and snake_case to PascalCase
    s.split(&['-', '_'][..])
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

// Template-based converter generators

fn generate_roman_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &FxHashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Sort by length (longest first) for proper matching
    let mut sorted_mappings: Vec<_> = mappings.iter().collect();
    sorted_mappings.sort_by(|a, b| b.0.len().cmp(&a.0.len()));

    // Prepare reverse priority mappings for template
    let reverse_priority_mappings: FxHashMap<&str, &str> = sorted_mappings
        .iter()
        .filter(|(_from, to)| to.len() > 1) // Multi-character sequences get priority
        .map(|(from, to)| (to.as_str(), from.as_str()))
        .collect();

    // Convert to JSON for template
    let mappings_json: FxHashMap<&str, &str> = mappings
        .iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    // Add script-specific aliases
    let aliases = match script_name {
        "harvard_kyoto" => vec![
            ("hk_to_iso", "harvard_kyoto_to_iso"),
            ("iso_to_hk", "iso_to_harvard_kyoto"),
        ],
        _ => vec![],
    };

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "mappings": mappings_json,
        "reverse_priority_mappings": reverse_priority_mappings,
        "aliases": aliases
    });

    let code = handlebars.render("roman_converter", &template_data)?;
    Ok(code)
}

// Handlebars helper functions
fn uppercase_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&param.to_uppercase())?;
    Ok(())
}

fn lowercase_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&param.to_lowercase())?;
    Ok(())
}

fn capitalize_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&capitalize_first(param))?;
    Ok(())
}

fn escape_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&escape_string(param))?;
    Ok(())
}

fn generate_indic_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &FxHashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Filter to only single-character mappings for optimized HashMap<char, char>
    let char_mappings: FxHashMap<&str, &str> = mappings
        .iter()
        .filter(|(from, to)| from.chars().count() == 1 && to.chars().count() == 1)
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "char_mappings": char_mappings
    });

    let code = handlebars.render("indic_standard_converter", &template_data)?;
    Ok(code)
}

fn generate_extended_indic_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &FxHashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Use all mappings as strings for complex script support
    let string_mappings: FxHashMap<&str, &str> = mappings
        .iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "string_mappings": string_mappings
    });

    let code = handlebars.render("indic_extended_converter", &template_data)?;
    Ok(code)
}

fn generate_roman_to_devanagari_converter(
    handlebars: &Handlebars,
    schema: &ScriptSchema,
) -> Result<String, Box<dyn std::error::Error>> {
    let script_name = &schema.metadata.name;
    let struct_name = format!("{}DevanagariConverter", capitalize_first(script_name));

    // Get ISO-15919 to Devanagari mappings from hub (at compile time)
    let iso_to_deva_mappings = get_iso_to_devanagari_mappings();

    // Compose Roman → ISO-15919 → Devanagari mappings at COMPILE TIME
    let mut roman_to_deva_mappings = FxHashMap::default();
    
    // Process all mapping categories from the schema
    let all_roman_mappings = [
        &schema.mappings.vowels,
        &schema.mappings.consonants,
        &schema.mappings.marks,
        &schema.mappings.digits,
        &schema.mappings.sanskrit_extensions,
        &schema.mappings.special,
    ];

    for mapping_category in all_roman_mappings.iter() {
        if let Some(mappings) = mapping_category {
            for (roman_key, iso_value) in mappings.iter() {
                // Compose at compile time: Roman → ISO → Devanagari becomes Roman → Devanagari
                if let Some(deva_value) = iso_to_deva_mappings.get(iso_value.as_str()) {
                    roman_to_deva_mappings.insert(roman_key.clone(), deva_value.to_string());
                }
            }
        }
    }

    // Sort by length (longest first) for proper matching
    let mut sorted_mappings: Vec<_> = roman_to_deva_mappings.iter().collect();
    sorted_mappings.sort_by(|a, b| b.0.len().cmp(&a.0.len()));

    // Convert to template format
    let mappings_for_template: FxHashMap<&str, &str> = sorted_mappings
        .iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": format!("{}_devanagari", script_name),
        "original_script": script_name,
        "has_implicit_a": schema.metadata.has_implicit_a,
        "mappings": mappings_for_template,
    });

    let code = handlebars.render("roman_to_devanagari_direct", &template_data)?;
    Ok(code)
}

fn get_iso_to_devanagari_mappings() -> FxHashMap<&'static str, &'static str> {
    let mut iso_to_deva = FxHashMap::default();

    // Core vowels
    iso_to_deva.insert("a", "अ");
    iso_to_deva.insert("ā", "आ");
    iso_to_deva.insert("i", "इ");
    iso_to_deva.insert("ī", "ई");
    iso_to_deva.insert("u", "उ");
    iso_to_deva.insert("ū", "ऊ");
    iso_to_deva.insert("r̥", "ऋ");
    iso_to_deva.insert("r̥̄", "ॠ");
    iso_to_deva.insert("l̥", "ऌ");
    iso_to_deva.insert("l̥̄", "ॡ");
    iso_to_deva.insert("e", "ए");
    iso_to_deva.insert("ai", "ऐ");
    iso_to_deva.insert("o", "ओ");
    iso_to_deva.insert("au", "औ");

    // Consonants (with inherent 'a' - add halanta for consonant-only forms)
    iso_to_deva.insert("k", "क्");
    iso_to_deva.insert("kh", "ख्");
    iso_to_deva.insert("g", "ग्");
    iso_to_deva.insert("gh", "घ्");
    iso_to_deva.insert("ṅ", "ङ्");
    iso_to_deva.insert("c", "च्");
    iso_to_deva.insert("ch", "छ्");
    iso_to_deva.insert("j", "ज्");
    iso_to_deva.insert("jh", "झ्");
    iso_to_deva.insert("ñ", "ञ्");
    iso_to_deva.insert("ṭ", "ट्");
    iso_to_deva.insert("ṭh", "ठ्");
    iso_to_deva.insert("ḍ", "ड्");
    iso_to_deva.insert("ḍh", "ढ्");
    iso_to_deva.insert("ṇ", "ण्");
    iso_to_deva.insert("t", "त्");
    iso_to_deva.insert("th", "थ्");
    iso_to_deva.insert("d", "द्");
    iso_to_deva.insert("dh", "ध्");
    iso_to_deva.insert("n", "न्");
    iso_to_deva.insert("p", "प्");
    iso_to_deva.insert("ph", "फ्");
    iso_to_deva.insert("b", "ब्");
    iso_to_deva.insert("bh", "भ्");
    iso_to_deva.insert("m", "म्");
    iso_to_deva.insert("y", "य्");
    iso_to_deva.insert("r", "र्");
    iso_to_deva.insert("l", "ल्");
    iso_to_deva.insert("v", "व्");
    iso_to_deva.insert("ś", "श्");
    iso_to_deva.insert("ṣ", "ष्");
    iso_to_deva.insert("s", "स्");
    iso_to_deva.insert("h", "ह्");

    // Marks
    iso_to_deva.insert("ṁ", "ं");
    iso_to_deva.insert("ḥ", "ः");
    iso_to_deva.insert("m̐", "ँ");
    iso_to_deva.insert("'", "ऽ");

    // Digits
    iso_to_deva.insert("0", "०");
    iso_to_deva.insert("1", "१");
    iso_to_deva.insert("2", "२");
    iso_to_deva.insert("3", "३");
    iso_to_deva.insert("4", "४");
    iso_to_deva.insert("5", "५");
    iso_to_deva.insert("6", "६");
    iso_to_deva.insert("7", "७");
    iso_to_deva.insert("8", "८");
    iso_to_deva.insert("9", "९");

    // Special
    iso_to_deva.insert("ḷ", "ळ्");
    iso_to_deva.insert("।", "।");
    iso_to_deva.insert("॥", "॥");
    iso_to_deva.insert("kṣ", "क्ष्");
    iso_to_deva.insert("jñ", "ज्ञ्");

    iso_to_deva
}
