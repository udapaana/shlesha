use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::collections::HashMap;
use handlebars::Handlebars;
use serde_json::json;

#[derive(serde::Deserialize, Debug)]
struct ScriptMetadata {
    name: String,
    script_type: String,
    has_implicit_a: bool,
}

#[derive(serde::Deserialize, Debug)]
struct ScriptMappings {
    vowels: Option<HashMap<String, String>>,
    consonants: Option<HashMap<String, String>>,
    vowel_signs: Option<HashMap<String, String>>,
    marks: Option<HashMap<String, String>>,
    digits: Option<HashMap<String, String>>,
    sanskrit_extensions: Option<HashMap<String, String>>,
    special: Option<HashMap<String, String>>,
}

#[derive(serde::Deserialize, Debug)]
struct CodegenConfig {
    mapping_type: String,
    processor_type: String,
}

#[derive(serde::Deserialize, Debug)]
struct ScriptSchema {
    metadata: ScriptMetadata,
    mappings: ScriptMappings,
    codegen: Option<CodegenConfig>,
}

fn main() {
    println!("cargo:rerun-if-changed=schemas/");
    println!("cargo:rerun-if-changed=mappings/");
    
    if let Err(e) = generate_schema_based_converters() {
        println!("cargo:warning=Failed to generate schema-based converters: {}", e);
    }
}

fn generate_schema_based_converters() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let schemas_dir = Path::new("schemas");
    let mappings_dir = Path::new("mappings");
    
    // Initialize Handlebars template engine
    let mut handlebars = Handlebars::new();
    handlebars.register_template_file("roman_converter", "templates/roman_converter.hbs")?;
    handlebars.register_template_file("indic_standard_converter", "templates/indic_standard_converter.hbs")?;
    handlebars.register_template_file("indic_extended_converter", "templates/indic_extended_converter.hbs")?;
    
    // Register helper functions for templates
    handlebars.register_helper("uppercase", Box::new(uppercase_helper));
    handlebars.register_helper("lowercase", Box::new(lowercase_helper));
    handlebars.register_helper("escape", Box::new(escape_helper));
    
    let mut generated_code = String::new();
    let mut converter_registrations = Vec::new();
    
    // Add header
    generated_code.push_str(r#"
// Auto-generated converters from TOML/YAML schemas
// DO NOT EDIT - Generated by build.rs at compile time

use rustc_hash::FxHashMap;
use once_cell::sync::Lazy;
use crate::modules::script_converter::processors::RomanScriptProcessor;

"#);

    // Process YAML schemas
    if schemas_dir.exists() {
        for entry in fs::read_dir(schemas_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.extension().and_then(|s| s.to_str()) == Some("yaml") {
                println!("cargo:rerun-if-changed={}", path.display());
                
                let content = fs::read_to_string(&path)?;
                let schema: ScriptSchema = serde_yaml::from_str(&content)
                    .map_err(|e| format!("Failed to parse YAML schema {}: {}", path.display(), e))?;
                
                // Skip Devanagari as it's the hub script and handled directly
                if schema.metadata.name.to_lowercase() == "devanagari" {
                    continue;
                }
                
                let converter_code = generate_converter_from_schema(&handlebars, &schema)
                    .map_err(|e| format!("Failed to generate converter for {}: {}", schema.metadata.name, e))?;
                generated_code.push_str(&converter_code);
                
                converter_registrations.push(format!("{}Converter", capitalize_first(&schema.metadata.name)));
            }
        }
    }
    
    // Process TOML mappings 
    if mappings_dir.exists() {
        for entry in fs::read_dir(mappings_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                continue;
            }
            
            if path.extension().and_then(|s| s.to_str()) == Some("toml") {
                println!("cargo:rerun-if-changed={}", path.display());
                
                let content = fs::read_to_string(&path)?;
                let toml_value: toml::Value = toml::from_str(&content)?;
                
                if let Some(converter_code) = generate_converter_from_toml(&handlebars, &toml_value)? {
                    generated_code.push_str(&converter_code);
                    
                    // Extract script name from filename
                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                        converter_registrations.push(format!("{}Converter", capitalize_first(stem)));
                    }
                }
            }
        }
    }
    
    // Add registration function
    generated_code.push_str(&format!(r#"
/// Register all schema-generated converters
pub fn register_schema_generated_converters(registry: &mut crate::modules::script_converter::ScriptConverterRegistry) {{
{}
}}
"#, 
        converter_registrations.iter()
            .map(|name| format!("    registry.register_converter(Box::new({}::new()));", name))
            .collect::<Vec<_>>()
            .join("\n")
    ));
    
    // Write generated code
    fs::write(out_dir.join("schema_generated.rs"), generated_code)?;
    
    Ok(())
}

fn generate_converter_from_schema(handlebars: &Handlebars, schema: &ScriptSchema) -> Result<String, Box<dyn std::error::Error>> {
    let script_name = &schema.metadata.name;
    let struct_name = format!("{}Converter", capitalize_first(script_name));
    
    let processor_type = schema.codegen.as_ref()
        .map(|c| c.processor_type.as_str())
        .unwrap_or(if schema.metadata.script_type == "roman" { "roman" } else { "indic_standard" });
    
    // Combine all mappings
    let mut all_mappings = HashMap::new();
    if let Some(ref vowels) = schema.mappings.vowels {
        all_mappings.extend(vowels.clone());
    }
    if let Some(ref consonants) = schema.mappings.consonants {
        all_mappings.extend(consonants.clone());
    }
    if let Some(ref vowel_signs) = schema.mappings.vowel_signs {
        all_mappings.extend(vowel_signs.clone());
    }
    if let Some(ref marks) = schema.mappings.marks {
        all_mappings.extend(marks.clone());
    }
    if let Some(ref digits) = schema.mappings.digits {
        all_mappings.extend(digits.clone());
    }
    if let Some(ref sanskrit_extensions) = schema.mappings.sanskrit_extensions {
        all_mappings.extend(sanskrit_extensions.clone());
    }
    if let Some(ref special) = schema.mappings.special {
        all_mappings.extend(special.clone());
    }
    
    match processor_type {
        "roman" => generate_roman_converter_with_template(handlebars, &struct_name, script_name, &all_mappings, &schema.metadata),
        "indic_standard" => generate_indic_converter_with_template(handlebars, &struct_name, script_name, &all_mappings, &schema.metadata),
        "indic_extended" => generate_extended_indic_converter_with_template(handlebars, &struct_name, script_name, &all_mappings, &schema.metadata),
        _ => Err(format!("Unknown processor type: {}", processor_type).into()),
    }
}

fn generate_converter_from_toml(handlebars: &Handlebars, toml_value: &toml::Value) -> Result<Option<String>, Box<dyn std::error::Error>> {
    // Extract metadata
    let metadata = toml_value.get("metadata").ok_or("Missing metadata section")?;
    let script_name = match metadata.get("script").and_then(|v| v.as_str()) {
        Some(name) => name,
        None => return Ok(None), // Skip files that don't define a script converter
    };
    let script_type = metadata.get("script_type")
        .and_then(|v| v.as_str())
        .unwrap_or("roman");
    let has_implicit_a = metadata.get("has_implicit_a")
        .and_then(|v| v.as_bool())
        .unwrap_or(false);
    
    if script_type != "roman" {
        return Ok(None); // Skip non-Roman scripts from TOML for now
    }
    
    let struct_name = format!("{}Converter", capitalize_first(script_name));
    
    // Extract mappings
    let mut mappings = HashMap::new();
    if let Some(to_iso) = toml_value.get("to_iso") {
        extract_toml_mappings(to_iso, &mut mappings);
    }
    
    let metadata_struct = ScriptMetadata {
        name: script_name.to_string(),
        script_type: script_type.to_string(),
        has_implicit_a,
    };
    
    let code = generate_roman_converter_with_template(handlebars, &struct_name, script_name, &mappings, &metadata_struct)?;
    Ok(Some(code))
}

fn extract_toml_mappings(value: &toml::Value, mappings: &mut HashMap<String, String>) {
    match value {
        toml::Value::Table(table) => {
            for (key, val) in table {
                if let toml::Value::Table(_) = val {
                    // Handle nested tables (like vowels, consonants, etc.)
                    extract_toml_mappings(val, mappings);
                } else if let Some(string_val) = val.as_str() {
                    mappings.insert(key.clone(), string_val.to_string());
                }
            }
        },
        _ => {}
    }
}

fn capitalize_first(s: &str) -> String {
    // Convert kebab-case and snake_case to PascalCase
    s.split(&['-', '_'][..])
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

// Template-based converter generators

fn generate_roman_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str, 
    script_name: &str, 
    mappings: &HashMap<String, String>,
    metadata: &ScriptMetadata
) -> Result<String, Box<dyn std::error::Error>> {
    // Sort by length (longest first) for proper matching
    let mut sorted_mappings: Vec<_> = mappings.iter().collect();
    sorted_mappings.sort_by(|a, b| b.0.len().cmp(&a.0.len()));
    
    // Prepare reverse priority mappings for template
    let reverse_priority_mappings: HashMap<&str, &str> = sorted_mappings.iter()
        .filter(|(from, to)| to.len() > 1) // Multi-character sequences get priority
        .map(|(from, to)| (to.as_str(), from.as_str()))
        .collect();
    
    // Convert to JSON for template
    let mappings_json: HashMap<&str, &str> = mappings.iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();
    
    // Add script-specific aliases 
    let aliases = match script_name {
        "harvard_kyoto" => vec![("hk_to_iso", "harvard_kyoto_to_iso"), ("iso_to_hk", "iso_to_harvard_kyoto")],
        _ => vec![]
    };
    
    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "mappings": mappings_json,
        "reverse_priority_mappings": reverse_priority_mappings,
        "aliases": aliases
    });
    
    let code = handlebars.render("roman_converter", &template_data)?;
    Ok(code)
}

// Handlebars helper functions
fn uppercase_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&param.to_uppercase())?;
    Ok(())
}

fn lowercase_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&param.to_lowercase())?;
    Ok(())
}

fn escape_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&escape_string(param))?;
    Ok(())
}

fn generate_indic_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &HashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Filter to only single-character mappings for optimized HashMap<char, char>
    let char_mappings: HashMap<&str, &str> = mappings
        .iter()
        .filter(|(from, to)| from.chars().count() == 1 && to.chars().count() == 1)
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "char_mappings": char_mappings
    });

    let code = handlebars.render("indic_standard_converter", &template_data)?;
    Ok(code)
}

fn generate_extended_indic_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &HashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Use all mappings as strings for complex script support
    let string_mappings: HashMap<&str, &str> = mappings
        .iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "string_mappings": string_mappings
    });

    let code = handlebars.render("indic_extended_converter", &template_data)?;
    Ok(code)
}