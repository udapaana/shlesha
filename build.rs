use handlebars::Handlebars;
use serde_json::json;
use rustc_hash::FxHashMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(serde::Deserialize, Debug)]
struct ScriptMetadata {
    name: String,
    script_type: String,
    has_implicit_a: bool,
}

#[derive(serde::Deserialize, Debug)]
struct ScriptMappings {
    vowels: Option<FxHashMap<String, String>>,
    consonants: Option<FxHashMap<String, String>>,
    vowel_signs: Option<FxHashMap<String, String>>,
    marks: Option<FxHashMap<String, String>>,
    digits: Option<FxHashMap<String, String>>,
    sanskrit_extensions: Option<FxHashMap<String, String>>,
    special: Option<FxHashMap<String, String>>,
}

#[derive(serde::Deserialize, Debug)]
struct CodegenConfig {
    processor_type: String,
}

#[derive(serde::Deserialize, Debug)]
struct ScriptSchema {
    metadata: ScriptMetadata,
    target: Option<String>, // "iso15919" for Roman, "devanagari" for Indic (default)
    mappings: ScriptMappings,
    codegen: Option<CodegenConfig>,
}

fn main() {
    println!("cargo:rerun-if-changed=schemas/");

    if let Err(e) = generate_schema_based_converters() {
        println!("cargo:warning=Failed to generate schema-based converters: {e}");
    }
}

fn generate_schema_based_converters() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let schemas_dir = Path::new("schemas");

    // Initialize Handlebars template engine
    let mut handlebars = Handlebars::new();
    handlebars.register_template_file("roman_converter", "templates/roman_converter.hbs")?;
    handlebars.register_template_file(
        "indic_standard_converter",
        "templates/indic_standard_converter.hbs",
    )?;
    handlebars.register_template_file(
        "indic_extended_converter",
        "templates/indic_extended_converter.hbs",
    )?;

    // Register helper functions for templates
    handlebars.register_helper("uppercase", Box::new(uppercase_helper));
    handlebars.register_helper("lowercase", Box::new(lowercase_helper));
    handlebars.register_helper("escape", Box::new(escape_helper));

    let mut generated_code = String::new();
    let mut converter_registrations = Vec::new();

    // Add header
    generated_code.push_str(
        r#"
// Auto-generated converters from TOML/YAML schemas
// DO NOT EDIT - Generated by build.rs at compile time

use once_cell::sync::Lazy;
use crate::modules::script_converter::processors::RomanScriptProcessor;

"#,
    );

    // Process YAML schemas
    if schemas_dir.exists() {
        for entry in fs::read_dir(schemas_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("yaml") {
                println!("cargo:rerun-if-changed={}", path.display());

                let content = fs::read_to_string(&path)?;
                let schema: ScriptSchema = serde_yaml::from_str(&content).map_err(|e| {
                    format!("Failed to parse YAML schema {}: {}", path.display(), e)
                })?;

                // Skip Devanagari as it's the hub script and handled directly
                if schema.metadata.name.to_lowercase() == "devanagari" {
                    continue;
                }

                let converter_code =
                    generate_converter_from_schema(&handlebars, &schema).map_err(|e| {
                        format!(
                            "Failed to generate converter for {}: {}",
                            schema.metadata.name, e
                        )
                    })?;
                generated_code.push_str(&converter_code);

                converter_registrations.push(format!(
                    "{}Converter",
                    capitalize_first(&schema.metadata.name)
                ));
            }
        }
    }

    // Add registration function
    generated_code.push_str(&format!(r#"
/// Register all schema-generated converters
pub fn register_schema_generated_converters(registry: &mut crate::modules::script_converter::ScriptConverterRegistry) {{
{}
}}
"#, 
        converter_registrations.iter()
            .map(|name| format!("    registry.register_converter(Box::new({name}::new()));"))
            .collect::<Vec<_>>()
            .join("\n")
    ));

    // Write generated code
    fs::write(out_dir.join("schema_generated.rs"), generated_code)?;

    Ok(())
}

fn generate_converter_from_schema(
    handlebars: &Handlebars,
    schema: &ScriptSchema,
) -> Result<String, Box<dyn std::error::Error>> {
    let script_name = &schema.metadata.name;
    let struct_name = format!("{}Converter", capitalize_first(script_name));

    // Determine processor type based on target or script_type
    let processor_type = schema
        .codegen
        .as_ref()
        .map(|c| c.processor_type.as_str())
        .unwrap_or_else(|| {
            // Use target field to determine processor type
            match schema.target.as_deref() {
                Some("iso15919") => "roman",
                Some("devanagari") => "indic_standard",
                None => {
                    // Fallback to script_type for backward compatibility
                    if schema.metadata.script_type == "roman" {
                        "roman"
                    } else {
                        "indic_standard"
                    }
                }
                _ => "indic_standard",
            }
        });

    // Combine all mappings
    let mut all_mappings = FxHashMap::default();
    if let Some(ref vowels) = schema.mappings.vowels {
        all_mappings.extend(vowels.clone());
    }
    if let Some(ref consonants) = schema.mappings.consonants {
        all_mappings.extend(consonants.clone());
    }
    if let Some(ref vowel_signs) = schema.mappings.vowel_signs {
        all_mappings.extend(vowel_signs.clone());
    }
    if let Some(ref marks) = schema.mappings.marks {
        all_mappings.extend(marks.clone());
    }
    if let Some(ref digits) = schema.mappings.digits {
        all_mappings.extend(digits.clone());
    }
    if let Some(ref sanskrit_extensions) = schema.mappings.sanskrit_extensions {
        all_mappings.extend(sanskrit_extensions.clone());
    }
    if let Some(ref special) = schema.mappings.special {
        all_mappings.extend(special.clone());
    }

    match processor_type {
        "roman" => generate_roman_converter_with_template(
            handlebars,
            &struct_name,
            script_name,
            &all_mappings,
            &schema.metadata,
        ),
        "indic_standard" => generate_indic_converter_with_template(
            handlebars,
            &struct_name,
            script_name,
            &all_mappings,
            &schema.metadata,
        ),
        "indic_extended" => generate_extended_indic_converter_with_template(
            handlebars,
            &struct_name,
            script_name,
            &all_mappings,
            &schema.metadata,
        ),
        _ => Err(format!("Unknown processor type: {processor_type}").into()),
    }
}

fn capitalize_first(s: &str) -> String {
    // Convert kebab-case and snake_case to PascalCase
    s.split(&['-', '_'][..])
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

// Template-based converter generators

fn generate_roman_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &FxHashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Sort by length (longest first) for proper matching
    let mut sorted_mappings: Vec<_> = mappings.iter().collect();
    sorted_mappings.sort_by(|a, b| b.0.len().cmp(&a.0.len()));

    // Prepare reverse priority mappings for template
    let reverse_priority_mappings: FxHashMap<&str, &str> = sorted_mappings
        .iter()
        .filter(|(_from, to)| to.len() > 1) // Multi-character sequences get priority
        .map(|(from, to)| (to.as_str(), from.as_str()))
        .collect();

    // Convert to JSON for template
    let mappings_json: FxHashMap<&str, &str> = mappings
        .iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    // Add script-specific aliases
    let aliases = match script_name {
        "harvard_kyoto" => vec![
            ("hk_to_iso", "harvard_kyoto_to_iso"),
            ("iso_to_hk", "iso_to_harvard_kyoto"),
        ],
        _ => vec![],
    };

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "mappings": mappings_json,
        "reverse_priority_mappings": reverse_priority_mappings,
        "aliases": aliases
    });

    let code = handlebars.render("roman_converter", &template_data)?;
    Ok(code)
}

// Handlebars helper functions
fn uppercase_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&param.to_uppercase())?;
    Ok(())
}

fn lowercase_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&param.to_lowercase())?;
    Ok(())
}

fn escape_helper(
    h: &handlebars::Helper,
    _: &handlebars::Handlebars,
    _: &handlebars::Context,
    _rc: &mut handlebars::RenderContext,
    out: &mut dyn handlebars::Output,
) -> handlebars::HelperResult {
    let param = h.param(0).unwrap().value().as_str().unwrap();
    out.write(&escape_string(param))?;
    Ok(())
}

fn generate_indic_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &FxHashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Filter to only single-character mappings for optimized HashMap<char, char>
    let char_mappings: FxHashMap<&str, &str> = mappings
        .iter()
        .filter(|(from, to)| from.chars().count() == 1 && to.chars().count() == 1)
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "char_mappings": char_mappings
    });

    let code = handlebars.render("indic_standard_converter", &template_data)?;
    Ok(code)
}

fn generate_extended_indic_converter_with_template(
    handlebars: &Handlebars,
    struct_name: &str,
    script_name: &str,
    mappings: &FxHashMap<String, String>,
    metadata: &ScriptMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    // Use all mappings as strings for complex script support
    let string_mappings: FxHashMap<&str, &str> = mappings
        .iter()
        .map(|(k, v)| (k.as_str(), v.as_str()))
        .collect();

    let template_data = json!({
        "struct_name": struct_name,
        "script_name": script_name,
        "has_implicit_a": metadata.has_implicit_a,
        "string_mappings": string_mappings
    });

    let code = handlebars.render("indic_extended_converter", &template_data)?;
    Ok(code)
}
