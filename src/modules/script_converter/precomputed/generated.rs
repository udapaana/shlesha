//! Pre-computed direct script converters
//! This file is auto-generated by build.rs - DO NOT EDIT

use std::collections::HashMap;
use super::super::{ScriptConverter, ConverterError};
use crate::modules::hub::HubInput;


/// Direct converter from iast to devanagari
pub struct IastToDevanagariDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl IastToDevanagariDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // Basic vowels
        mappings.insert("a", "अ");
        mappings.insert("ā", "आ");
        mappings.insert("i", "इ");
        mappings.insert("ī", "ई");
        mappings.insert("u", "उ");
        mappings.insert("ū", "ऊ");
        
        // Consonants with inherent 'a'
        mappings.insert("ka", "क");
        mappings.insert("kha", "ख");
        mappings.insert("ga", "ग");
        mappings.insert("gha", "घ");
        mappings.insert("ṅa", "ङ");
        
        // More mappings would be generated from actual file parsing...

        Self { mappings }
    }
    
    fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for IastToDevanagariDirect {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["iast", "devanagari"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

/// Direct converter from devanagari to iast
pub struct DevanagariToIastDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl DevanagariToIastDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // Basic vowels
        mappings.insert("अ", "a");
        mappings.insert("आ", "ā");
        mappings.insert("इ", "i");
        mappings.insert("ई", "ī");
        mappings.insert("उ", "u");
        mappings.insert("ऊ", "ū");
        
        // Consonants (without inherent 'a')
        mappings.insert("क", "ka");
        mappings.insert("ख", "kha");
        mappings.insert("ग", "ga");
        mappings.insert("घ", "gha");
        mappings.insert("ङ", "ṅa");
        
        // More mappings would be generated from actual file parsing...

        Self { mappings }
    }
    
    fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for DevanagariToIastDirect {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["devanagari", "iast"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

/// Direct converter from itrans to devanagari
pub struct ItransToDevanagariDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl ItransToDevanagariDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // Basic vowels
        mappings.insert("a", "अ");
        mappings.insert("ā", "आ");
        mappings.insert("i", "इ");
        mappings.insert("ī", "ई");
        mappings.insert("u", "उ");
        mappings.insert("ū", "ऊ");
        
        // Consonants with inherent 'a'
        mappings.insert("ka", "क");
        mappings.insert("kha", "ख");
        mappings.insert("ga", "ग");
        mappings.insert("gha", "घ");
        mappings.insert("ṅa", "ङ");
        
        // More mappings would be generated from actual file parsing...

        Self { mappings }
    }
    
    fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for ItransToDevanagariDirect {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["itrans", "devanagari"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

/// Direct converter from devanagari to itrans
pub struct DevanagariToItransDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl DevanagariToItransDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // Basic vowels
        mappings.insert("अ", "a");
        mappings.insert("आ", "ā");
        mappings.insert("इ", "i");
        mappings.insert("ई", "ī");
        mappings.insert("उ", "u");
        mappings.insert("ऊ", "ū");
        
        // Consonants (without inherent 'a')
        mappings.insert("क", "ka");
        mappings.insert("ख", "kha");
        mappings.insert("ग", "ga");
        mappings.insert("घ", "gha");
        mappings.insert("ङ", "ṅa");
        
        // More mappings would be generated from actual file parsing...

        Self { mappings }
    }
    
    fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for DevanagariToItransDirect {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["devanagari", "itrans"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

/// Direct converter from slp1 to devanagari
pub struct Slp1ToDevanagariDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl Slp1ToDevanagariDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // Basic vowels
        mappings.insert("a", "अ");
        mappings.insert("ā", "आ");
        mappings.insert("i", "इ");
        mappings.insert("ī", "ई");
        mappings.insert("u", "उ");
        mappings.insert("ū", "ऊ");
        
        // Consonants with inherent 'a'
        mappings.insert("ka", "क");
        mappings.insert("kha", "ख");
        mappings.insert("ga", "ग");
        mappings.insert("gha", "घ");
        mappings.insert("ṅa", "ङ");
        
        // More mappings would be generated from actual file parsing...

        Self { mappings }
    }
    
    fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for Slp1ToDevanagariDirect {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["slp1", "devanagari"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

/// Direct converter from devanagari to slp1
pub struct DevanagariToSlp1Direct {
    mappings: HashMap<&'static str, &'static str>,
}

impl DevanagariToSlp1Direct {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // Basic vowels
        mappings.insert("अ", "a");
        mappings.insert("आ", "ā");
        mappings.insert("इ", "i");
        mappings.insert("ई", "ī");
        mappings.insert("उ", "u");
        mappings.insert("ऊ", "ū");
        
        // Consonants (without inherent 'a')
        mappings.insert("क", "ka");
        mappings.insert("ख", "kha");
        mappings.insert("ग", "ga");
        mappings.insert("घ", "gha");
        mappings.insert("ङ", "ṅa");
        
        // More mappings would be generated from actual file parsing...

        Self { mappings }
    }
    
    fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for DevanagariToSlp1Direct {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["devanagari", "slp1"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

pub struct PrecomputedRegistry {
    converters: HashMap<(String, String), Box<dyn ScriptConverter>>,
}

impl PrecomputedRegistry {
    pub fn new() -> Self {
        let mut converters: HashMap<(String, String), Box<dyn ScriptConverter>> = HashMap::new();
        
        converters.insert(("iast".to_string(), "devanagari".to_string()), Box::new(IastToDevanagariDirect::new()));
        converters.insert(("devanagari".to_string(), "iast".to_string()), Box::new(DevanagariToIastDirect::new()));
        converters.insert(("itrans".to_string(), "devanagari".to_string()), Box::new(ItransToDevanagariDirect::new()));
        converters.insert(("devanagari".to_string(), "itrans".to_string()), Box::new(DevanagariToItransDirect::new()));
        converters.insert(("slp1".to_string(), "devanagari".to_string()), Box::new(Slp1ToDevanagariDirect::new()));
        converters.insert(("devanagari".to_string(), "slp1".to_string()), Box::new(DevanagariToSlp1Direct::new()));

        Self { converters }
    }
    
    pub fn get(&self, from: &str, to: &str) -> Option<&Box<dyn ScriptConverter>> {
        self.converters.get(&(from.to_string(), to.to_string()))
    }
}

impl Default for PrecomputedRegistry {
    fn default() -> Self {
        Self::new()
    }
}
