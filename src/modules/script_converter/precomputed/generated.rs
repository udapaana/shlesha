//! Pre-computed direct script converters
//! This file is auto-generated by build.rs - DO NOT EDIT

use std::collections::HashMap;
use super::super::{ScriptConverter, ConverterError};
use crate::modules::hub::HubInput;

// Additional trait for direct conversion
pub trait DirectConverter {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError>;
}


/// Direct converter from iast to devanagari
pub struct IastToDevanagariDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl IastToDevanagariDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        mappings.insert("e", "ए");
        mappings.insert("ṛ", "ऋ");
        mappings.insert("kha", "ख");
        mappings.insert("ca", "च");
        mappings.insert("da", "द");
        mappings.insert("ra", "र");
        mappings.insert("au", "औ");
        mappings.insert("pha", "फ");
        mappings.insert("ḷ", "ऌ");
        mappings.insert("gha", "घ");
        mappings.insert("ba", "ब");
        mappings.insert("bha", "भ");
        mappings.insert("ja", "ज");
        mappings.insert("ṭha", "ठ");
        mappings.insert("ḍa", "ड");
        mappings.insert("ta", "त");
        mappings.insert("ṭa", "ट");
        mappings.insert("śa", "श");
        mappings.insert("ṣa", "ष");
        mappings.insert("ha", "ह");
        mappings.insert("ṝ", "ॠ");
        mappings.insert("o", "ओ");
        mappings.insert("la", "ल");
        mappings.insert("i", "इ");
        mappings.insert("ī", "ई");
        mappings.insert("ṅa", "ङ");
        mappings.insert("ā", "आ");
        mappings.insert("a", "अ");
        mappings.insert("ḹ", "ॡ");
        mappings.insert("jha", "झ");
        mappings.insert("ṇa", "ण");
        mappings.insert("tha", "थ");
        mappings.insert("dha", "ध");
        mappings.insert("na", "न");
        mappings.insert("u", "उ");
        mappings.insert("ai", "ऐ");
        mappings.insert("cha", "छ");
        mappings.insert("ka", "क");
        mappings.insert("ga", "ग");
        mappings.insert("pa", "प");
        mappings.insert("ma", "म");
        mappings.insert("ya", "य");
        mappings.insert("ḍha", "ढ");
        mappings.insert("va", "व");
        mappings.insert("ū", "ऊ");
        mappings.insert("sa", "स");
        mappings.insert("ña", "ञ");

        Self { mappings }
    }
    
    pub fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for IastToDevanagariDirect {
    fn to_hub(&self, _script: &str, _input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, _script: &str, _hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["iast", "devanagari"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

impl DirectConverter for IastToDevanagariDirect {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError> {
        self.convert(input)
    }
}

/// Direct converter from devanagari to iast
pub struct DevanagariToIastDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl DevanagariToIastDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        mappings.insert("क", "ka");

        Self { mappings }
    }
    
    pub fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for DevanagariToIastDirect {
    fn to_hub(&self, _script: &str, _input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, _script: &str, _hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["devanagari", "iast"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

impl DirectConverter for DevanagariToIastDirect {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError> {
        self.convert(input)
    }
}

/// Direct converter from itrans to devanagari
pub struct ItransToDevanagariDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl ItransToDevanagariDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        mappings.insert("a", "अ");
        mappings.insert("U", "ऊ");
        mappings.insert("I", "ई");
        mappings.insert("i", "इ");
        mappings.insert("gha", "घ");
        mappings.insert("ga", "ग");
        mappings.insert("kha", "ख");
        mappings.insert("u", "उ");
        mappings.insert("ka", "क");
        mappings.insert("A", "आ");

        Self { mappings }
    }
    
    pub fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for ItransToDevanagariDirect {
    fn to_hub(&self, _script: &str, _input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, _script: &str, _hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["itrans", "devanagari"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

impl DirectConverter for ItransToDevanagariDirect {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError> {
        self.convert(input)
    }
}

/// Direct converter from devanagari to itrans
pub struct DevanagariToItransDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl DevanagariToItransDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        mappings.insert("क", "ka");

        Self { mappings }
    }
    
    pub fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for DevanagariToItransDirect {
    fn to_hub(&self, _script: &str, _input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, _script: &str, _hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["devanagari", "itrans"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

impl DirectConverter for DevanagariToItransDirect {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError> {
        self.convert(input)
    }
}

/// Direct converter from slp1 to devanagari
pub struct Slp1ToDevanagariDirect {
    mappings: HashMap<&'static str, &'static str>,
}

impl Slp1ToDevanagariDirect {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        mappings.insert("I", "ई");
        mappings.insert("u", "उ");
        mappings.insert("ga", "ग");
        mappings.insert("Ka", "ख");
        mappings.insert("Ga", "घ");
        mappings.insert("i", "इ");
        mappings.insert("ka", "क");
        mappings.insert("a", "अ");
        mappings.insert("A", "आ");
        mappings.insert("U", "ऊ");

        Self { mappings }
    }
    
    pub fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for Slp1ToDevanagariDirect {
    fn to_hub(&self, _script: &str, _input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, _script: &str, _hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["slp1", "devanagari"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

impl DirectConverter for Slp1ToDevanagariDirect {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError> {
        self.convert(input)
    }
}

/// Direct converter from devanagari to slp1
pub struct DevanagariToSlp1Direct {
    mappings: HashMap<&'static str, &'static str>,
}

impl DevanagariToSlp1Direct {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();
        mappings.insert("क", "ka");

        Self { mappings }
    }
    
    pub fn convert(&self, input: &str) -> Result<String, ConverterError> {
        use super::super::processors::RomanScriptProcessor;
        RomanScriptProcessor::process_optimized(input, &self.mappings)
    }
}

impl ScriptConverter for DevanagariToSlp1Direct {
    fn to_hub(&self, _script: &str, _input: &str) -> Result<HubInput, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use to_hub".to_string(),
        })
    }
    
    fn from_hub(&self, _script: &str, _hub_input: &HubInput) -> Result<String, ConverterError> {
        // Direct converters bypass the hub
        Err(ConverterError::ConversionFailed {
            script: _script.to_string(),
            reason: "Direct converter should not use from_hub".to_string(),
        })
    }
    
    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["devanagari", "slp1"]
    }
    
    fn script_has_implicit_a(&self, _script: &str) -> bool {
        false // Direct converters handle this internally
    }
}

impl DirectConverter for DevanagariToSlp1Direct {
    fn convert_direct(&self, input: &str) -> Result<String, ConverterError> {
        self.convert(input)
    }
}

pub struct PrecomputedRegistry {
    converters: HashMap<(String, String), Box<dyn ScriptConverter>>,
}

impl PrecomputedRegistry {
    pub fn new() -> Self {
        let mut converters: HashMap<(String, String), Box<dyn ScriptConverter>> = HashMap::new();
        
        converters.insert(("iast".to_string(), "devanagari".to_string()), Box::new(IastToDevanagariDirect::new()));
        converters.insert(("devanagari".to_string(), "iast".to_string()), Box::new(DevanagariToIastDirect::new()));
        converters.insert(("itrans".to_string(), "devanagari".to_string()), Box::new(ItransToDevanagariDirect::new()));
        converters.insert(("devanagari".to_string(), "itrans".to_string()), Box::new(DevanagariToItransDirect::new()));
        converters.insert(("slp1".to_string(), "devanagari".to_string()), Box::new(Slp1ToDevanagariDirect::new()));
        converters.insert(("devanagari".to_string(), "slp1".to_string()), Box::new(DevanagariToSlp1Direct::new()));

        Self { converters }
    }
    
    pub fn get(&self, from: &str, to: &str) -> Option<&Box<dyn ScriptConverter>> {
        self.converters.get(&(from.to_string(), to.to_string()))
    }
    
    pub fn has_direct_mapping(&self, from: &str, to: &str) -> bool {
        self.converters.contains_key(&(from.to_string(), to.to_string()))
    }
    
    pub fn convert_direct(&self, from: &str, to: &str, input: &str) -> Option<Result<String, ConverterError>> {
        // Since we can't call convert_direct through the trait object,
        // we'll need to use a different approach or return None to use hub conversion
        None
    }
}

impl Default for PrecomputedRegistry {
    fn default() -> Self {
        Self::new()
    }
}
