// Generated Hub token conversion implementation

use crate::modules::hub::tokens::{AbugidaToken, AlphabetToken, HubToken, HubTokenSequence};
use crate::modules::hub::{HubError, HubTrait};
use rustc_hash::FxHashMap;
use once_cell::sync::Lazy;

#[derive(Default)]
pub struct GeneratedHub;

// Optimized lookup tables for ultra-fast token conversion
static ABUGIDA_TO_ALPHABET_MAP: Lazy<FxHashMap<AbugidaToken, AlphabetToken>> = Lazy::new(|| {
    let mut map = FxHashMap::default();
    {{#each abugida_to_alphabet_mappings}}
    {{#unless special_handling}}
    map.insert(AbugidaToken::{{abugida_token}}, AlphabetToken::{{alphabet_token}});
    {{/unless}}
    {{/each}}
    map
});

static ALPHABET_TO_ABUGIDA_MAP: Lazy<FxHashMap<AlphabetToken, AbugidaToken>> = Lazy::new(|| {
    let mut map = FxHashMap::default();
    {{#each alphabet_to_abugida_mappings}}
    {{#unless special_handling}}
    map.insert(AlphabetToken::{{alphabet_token}}, AbugidaToken::{{abugida_token}});
    {{/unless}}
    {{/each}}
    map
});

impl GeneratedHub {
    pub fn new() -> Self {
        Self
    }
}

impl HubTrait for GeneratedHub {
    fn abugida_to_alphabet_tokens(&self, tokens: &HubTokenSequence) -> Result<HubTokenSequence, HubError> {
        let mut result = Vec::new();
        let mut i = 0;
        
        while i < tokens.len() {
            match &tokens[i] {
                HubToken::Abugida(abugida_token) => {
                    match abugida_token {
{{#each abugida_to_alphabet_mappings}}
{{#if special_handling}}
                        AbugidaToken::{{abugida_token}} => {
                            // Special handling: {{special_handling}}
{{#unless (eq special_handling "drop")}}
                            // Skip unknown token
{{/unless}}
                        }
{{else}}
                        AbugidaToken::{{abugida_token}} => {
                            result.push(HubToken::Alphabet(AlphabetToken::{{alphabet_token}}));
                        }
{{/if}}
{{/each}}
                        AbugidaToken::Unknown(c) => {
                            // Pass through unknown characters as alphabet tokens
                            result.push(HubToken::Alphabet(AlphabetToken::Unknown(*c)));
                        }
                        _ => {
                            // For unmapped tokens, return error or skip - depends on policy
                            return Err(HubError::MappingNotFound(format!("No mapping found for abugida token: {:?}", abugida_token)));
                        }
                    }
                }
                HubToken::Alphabet(alphabet_token) => {
                    // Already alphabet, pass through
                    result.push(HubToken::Alphabet(alphabet_token.clone()));
                }
            }
            i += 1;
        }
        
        Ok(result)
    }
    
    fn alphabet_to_abugida_tokens(&self, tokens: &HubTokenSequence) -> Result<HubTokenSequence, HubError> {
        let mut result = Vec::new();
        
        for token in tokens {
            match token {
                HubToken::Alphabet(alphabet_token) => {
                    match alphabet_token {
{{#each alphabet_to_abugida_mappings}}
{{#if special_handling}}
                        AlphabetToken::{{alphabet_token}} => {
                            // Skip alphabet token that has no abugida equivalent
                        }
{{else}}
                        AlphabetToken::{{alphabet_token}} => {
                            result.push(HubToken::Abugida(AbugidaToken::{{abugida_token}}));
                        }
{{/if}}
{{/each}}
                        // Handle special combinations that don't exist in AbugidaToken
                        AlphabetToken::SpecialKs => {
                            // kṣ -> क + ्ष
                            result.push(HubToken::Abugida(AbugidaToken::ConsonantK));
                            result.push(HubToken::Abugida(AbugidaToken::ConsonantSs));
                        }
                        AlphabetToken::SpecialJn => {
                            // jñ -> ज + ्ञ
                            result.push(HubToken::Abugida(AbugidaToken::ConsonantJ));
                            result.push(HubToken::Abugida(AbugidaToken::ConsonantNy));
                        }
                        AlphabetToken::Unknown(c) => {
                            // Pass through unknown characters
                            result.push(HubToken::Abugida(AbugidaToken::Unknown(*c)));
                        }
                        _ => {
                            // For unmapped tokens, return error or skip - depends on policy
                            return Err(HubError::MappingNotFound(format!("No mapping found for alphabet token: {:?}", alphabet_token)));
                        }
                    }
                }
                HubToken::Abugida(abugida_token) => {
                    // Already abugida, pass through
                    result.push(HubToken::Abugida(abugida_token.clone()));
                }
            }
        }
        
        Ok(result)
    }
}