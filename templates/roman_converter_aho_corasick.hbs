{{!-- Template for Ultra-Optimized Roman script converters using Aho-Corasick automaton --}}

// Pre-computed static mappings with Aho-Corasick for ultra-fast pattern matching
static {{uppercase script_name}}_TO_ISO_MAPPINGS: &[(&str, &str)] = &[
{{#each mappings}}
    ("{{escape @key}}", "{{escape this}}"),
{{/each}}
];

static ISO_TO_{{uppercase script_name}}_MAPPINGS: &[(&str, &str)] = &[
{{#each reverse_priority_mappings}}
    ("{{escape @key}}", "{{escape this}}"),
{{/each}}
];

static {{uppercase script_name}}_TO_ISO_AC: Lazy<(AhoCorasick, Vec<&'static str>)> = Lazy::new(|| {
    FastMappingBuilder::build_aho_corasick_mapping({{uppercase script_name}}_TO_ISO_MAPPINGS)
        .expect("Failed to build Aho-Corasick automaton for {{script_name}}")
});

static ISO_TO_{{uppercase script_name}}_AC: Lazy<(AhoCorasick, Vec<&'static str>)> = Lazy::new(|| {
    FastMappingBuilder::build_aho_corasick_mapping(ISO_TO_{{uppercase script_name}}_MAPPINGS)
        .expect("Failed to build Aho-Corasick automaton for reverse {{script_name}}")
});

/// Ultra-optimized {{script_name}} converter with Aho-Corasick automaton
pub struct {{struct_name}} {
    // Aho-Corasick automatons are stored as static references
}

impl {{struct_name}} {
    pub fn new() -> Self {
        Self {}
    }
    
    /// Convert {{script_name}} to ISO-15919 using Aho-Corasick automaton
    pub fn {{lowercase script_name}}_to_iso(&self, input: &str) -> Result<String, ConverterError> {
        let (ac, replacements) = &*{{uppercase script_name}}_TO_ISO_AC;
        RomanScriptProcessor::process_with_aho_corasick(input, ac, replacements)
    }
    
    /// Convert ISO-15919 to {{script_name}} using Aho-Corasick automaton
    pub fn iso_to_{{lowercase script_name}}(&self, input: &str) -> Result<String, ConverterError> {
        let (ac, replacements) = &*ISO_TO_{{uppercase script_name}}_AC;
        RomanScriptProcessor::process_with_aho_corasick(input, ac, replacements)
    }
    
    {{#each aliases}}
    /// Script-specific alias method
    pub fn {{this.[0]}}(&self, input: &str) -> Result<String, ConverterError> {
        self.{{this.[1]}}(input)
    }
    {{/each}}
}

impl ScriptConverter for {{struct_name}} {
    fn to_hub(&self, script: &str, input: &str) -> Result<HubInput, ConverterError> {
        if script != "{{script_name}}" {
            return Err(ConverterError::InvalidInput {
                script: script.to_string(),
                message: "{{struct_name}} converter only supports '{{script_name}}' script".to_string(),
            });
        }

        let iso_text = self.{{lowercase script_name}}_to_iso(input)?;
        Ok(HubInput::Iso(iso_text))
    }

    fn from_hub(&self, script: &str, hub_input: &HubInput) -> Result<String, ConverterError> {
        if script != "{{script_name}}" {
            return Err(ConverterError::InvalidInput {
                script: script.to_string(),
                message: "{{struct_name}} converter only supports '{{script_name}}' script".to_string(),
            });
        }

        match hub_input {
            HubInput::Iso(iso_text) => self.iso_to_{{lowercase script_name}}(iso_text),
            HubInput::Devanagari(_) => Err(ConverterError::ConversionFailed {
                script: script.to_string(),
                reason: "{{struct_name}} converter expects ISO input, got Devanagari".to_string(),
            }),
        }
    }

    fn supported_scripts(&self) -> Vec<&'static str> {
        vec!["{{script_name}}"]
    }

    fn script_has_implicit_a(&self, _script: &str) -> bool {
        {{has_implicit_a}}
    }
}

impl Default for {{struct_name}} {
    fn default() -> Self {
        Self::new()
    }
}